library(tictoc)
library(iterators)
library(mvtnorm)
library(abind)
library(doParallel)
quickstop.R
source("quickstop.R")
?foreach
x <- runif(100)
y <- x + runif(100, -0.1, 0.1)
cor(x,y)
ys <- sample(y)
cor(x,ys)
ys <- sample(y)
cor(x,ys)
ys <- sample(y)
cor(x,ys)
ys <- sample(y)
cor(x,ys)
.Random.seed
RNGkind
RNGkind()
cor(x,y)
x <- scale(x)
y <- scale(y)
cor(x,y)
crossprod(x,y)
crossprod(t(x),y)
crossprod(x,t(y))
crossprod(t(y),x)
crossprod
?crossprod
x <- runif(100)
y <- x + runif(100, -0.1, 0.1)
x <- runif(100)
y <- x + runif(100, -0.1, 0.1)
cor(x,y)
x <- x/sum(x^2)
y <- scale(y)
cor(x,y)
crossprod(x,y)
x <- runif(100)
y <- x + runif(100, -0.1, 0.1)
cor(x,y)
x <- x/sum(x^2)
y <- y/sum(y^2)
cor(x,y)
crossprod(x,y)
x <- runif(100)
y <- x + runif(100, -0.1, 0.1)
cor(x,y)
x <- scale(x)
y <- scale(y)
crossprod(x/sum(x^2), y)
pearson.perm.test <- function(x, y, req_alpha){
    t0 <- cor(x,y, method="pearson")
    x <- scale(x)
    y <- scale(y)
    x <- x/sum(x^2)
    sampleFun <- function(){
      y <- sample(y)
      return(abs(crossprod(x,y)) > abs(t0))
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(list(t0 = t0, pvalue = p.value))
}
x
y
cor(x)y
cor(x,y)
pearson.perm.test(x,y, 0.001)
system.time(
pearson.perm.test <- function(x, y, req_alpha){
    t0 <- cor(x,y, method="pearson")
    x <- scale(x)
    y <- scale(y)
    x <- x/sum(x^2)
    sampleFun <- function(){
      y <- sample(y)
      return(abs(crossprod(x,y)) > abs(t0))
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(list(t0 = t0, pvalue = p.value))
}
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
system.time(pearson.perm.test(x,y, 0.001))
0.256*10000
0.256*10000/60
system.time(pearson.perm.test(x[1:50],y[1:50], 0.001))
pearson.perm.test(x[1:50],y[1:50])
pearson.perm.test(x[1:50],y[1:50], 0.01)
system.time(pearson.perm.test(x[1:50],y[1:50], 0.01))
system.time(pearson.perm.test(x[1:50],y[1:50], 0.001))
system.time(pearson.perm.test(x[1:50],y[1:50], 0.0001))
system.time(pearson.perm.test(x[1:50],y[1:50], 1e-60))
cor.test(x,y)
cor.test(x[1:50],y[1:50])
cor.test(x,sample(y))
system.time(pearson.perm.test(x[1:50],sample(y[1:50]), 1e-60))
pearson.perm.test(x[1:50],sample(y[1:50]), 1e-60)
pearson.perm.test(x[1:50],sample(y[1:50]), 1e-2)
pearson.perm.test(x[1:50],sample(y[1:50]), 1e-5)
pearson.perm.test(x[1:50],sample(y[1:50]), 1e-1)
system.time(pearson.perm.test(x[1:50],sample(y[1:50]), 1e-1))
wCI:::newPCI
paired.concordance.index.new
x
y
x <- runif(100)
y <- x + runif(100, -0.1, 0.1)
x
y
cor(x,y)
rCI.perm.test <- function(x, y, delta, req_alpha, outties = 1L){
    t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.integer(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.interger(outties), 
                          pyties = as.interger(outties), plogic = 1L)
    t0 <- t0res[1]/(t0res[1] + t0res[2])
    sampleFun <- function(){
      y <- sample(y)
      t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.integer(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.interger(outties), 
                          pyties = as.interger(outties), plogic = 1L)
      t0 <- t0res[1]/(t0res[1] + t0res[2])
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(list(t0 = t0, pvalue = p.value))
}
rCI.perm.test(x,y, 0.1, 0.01)
rCI.perm.test <- function(x, y, delta, req_alpha, outties = 1L){
    t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.integer(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
    t0 <- t0res[1]/(t0res[1] + t0res[2])
    sampleFun <- function(){
      y <- sample(y)
      t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.integer(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
      t0 <- t0res[1]/(t0res[1] + t0res[2])
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(list(t0 = t0, pvalue = p.value))
}
rCI.perm.test(x,y, 0.1, 0.01)
rCI.perm.test <- function(x, y, delta, req_alpha, outties = 1L){
    t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.numeric(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
    t0 <- t0res[1]/(t0res[1] + t0res[2])
    sampleFun <- function(){
      y <- sample(y)
      t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.numeric(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
      t0 <- t0res[1]/(t0res[1] + t0res[2])
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(list(t0 = t0, pvalue = p.value))
}
rCI.perm.test(x,y, 0.1, 0.01)
rCI.perm.test <- function(x, y, delta, req_alpha, outties = 1L){
    t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.numeric(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
    t0 <- t0res[1]/(t0res[1] + t0res[2])
    sampleFun <- function(){
      y <- sample(y)
      tres <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.numeric(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
      t <- tres[1]/(tres[1] + tres[2])
      return(abs(t-0.5) > abs(t0 - 0.5))
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(list(t0 = t0, pvalue = p.value))
}
rCI.perm.test(x,y, 0.1, 0.01)
rCI.perm.test(x,y, 0.1, 0.01)
rCI.perm.test(x,y, 0.1, 0.01)
rCI.perm.test(x,y, 0.1, 0.01)
rCI.perm.test(x,y, 0.01, 0.01)
rCI.perm.test(x,y, 0.5, 0.01)
rCI.perm.test(x,y, 0.5, 0.01, 0)
rCI.perm.test(x,y, 0.1, 0.01, 0)
rCI.perm.test(x,y, 0.01, 0.01, 0)
paired.concordance.index.new
rCI.perm.test <- function(x, y, delta, req_alpha, outties = 1L){
    outties <- as.integer(!outties)
    t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.numeric(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
    t0 <- t0res[1]/(t0res[1] + t0res[2])
    sampleFun <- function(){
      y <- sample(y)
      tres <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.numeric(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
      t <- tres[1]/(tres[1] + tres[2])
      return(abs(t-0.5) > abs(t0 - 0.5))
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(list(t0 = t0, pvalue = p.value))
}
library(doParallel)
rCI.perm.test(x,y, 0.01, 0.01, 0)
rCI.perm.test(x,y, 0.01, 0.01, 1)
pearson.perm.test <- function(x, y, req_alpha){
    t0 <- cor(x,y, method="pearson")
    x <- scale(x)
    y <- scale(y)
    x <- x/sum(x^2)
    sampleFun <- function(){
      y <- sample(y)
      return(abs(crossprod(x,y)) > abs(t0))
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(c(list(t0 = t0), p.value))
}
pearson.perm.test(x[1:50],sample(y[1:50]), 1e-1)
#####################################################################
### Code to investigate whether rCI is more robust against loosing power 
### as noise in the measurements increases - bivariate normal case
###
### Petr Smirnov, 2019
#####################################################################
library(wCI)
library(MASS)
library(tictoc)
library(iterators)
library(mvtnorm)
library(abind)
library(doParallel)
source("quickstop.R")
pearson.perm.test <- function(x, y, req_alpha){
    t0 <- cor(x,y, method="pearson")
    x <- scale(x)
    y <- scale(y)
    x <- x/sum(x^2)
    sampleFun <- function(){
      y <- sample(y)
      return(abs(crossprod(x,y)) > abs(t0))
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(c(list(t0 = t0), p.value))
}
rCI.perm.test <- function(x, y, delta, req_alpha, outties = 1L){
    outties <- as.integer(!outties)
    t0res <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.numeric(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
    t0 <- t0res[1]/(t0res[1] + t0res[2])
    sampleFun <- function(){
      y <- sample(y)
      tres <- wCI:::newPCI(as.numeric(x), as.numeric(y), 
                          as.numeric(length(x)), 
                          pdeltaX = as.numeric(delta), 
                          pdeltaY = as.numeric(delta), 
                          pxties = as.integer(outties), 
                          pyties = as.integer(outties), plogic = 1L)
      t <- tres[1]/(tres[1] + tres[2])
      return(abs(t-0.5) > abs(t0 - 0.5))
    }
    p.value <- quickstop(sampleFun, req_alpha = req_alpha)
    return(c(list(t0 = t0), p.value))
}
    require(MASS)
    require(wCI)
    require(rmutil)
install.packages("rmutil")
runPowerNormalNull <- function(exp_CI = 0.6, 
                           N = 50, 
                           sampleN = 10000, 
                           delta_vector = seq(0, 1, by = .05), 
                           propTrue=1, req_alpha=0.001){
  tau = 2*exp_CI - 1
  rho <- sin((pi*tau)/(2))
  
  altSigma <- c(1,rho,rho,1)
  dim(altSigma) <- c(2,2)
  
  nullSigma <- c(1,0,0,1)
  dim(nullSigma) <- c(2,2)
  
  res <- foreach(i = seq_len(sampleN), 
                 export=c("delta_vector", "nullSigma", "altSigma", "propTrue", "N", "req_alpha")) %dopar% {
    # if(i %% 10 == 0){print(i)}
    require(MASS)
    require(wCI)
    require(rmutil)
    ci_p <- numeric(length(delta_vector))
    mci_p <- numeric(length(delta_vector))
    pearson_p <- numeric(length(delta_vector))
    
    
    spearman_p <- numeric(length(delta_vector))
    
    if(runif(1) < propTrue){
      truth <- rep(1, times=length(delta_vector))
      sample_mat <- mvrnorm(n = N, mu = c(0,0), Sigma = altSigma)
      
      x <- sample_mat[,1]
      y <- sample_mat[,2]
    } else {
      truth <- rep(0, times=length(delta_vector))
      sample_mat <- mvrnorm(n = N, mu = c(0,0), Sigma = nullSigma)
      
      x <- sample_mat[,1]
      y <- sample_mat[,2]
    }
    pearson_p_1 <- pearson.perm.test(x,y,req_alpha = req_alpha)$p.value
    spearman_p_1 <- cor.test(x, y, method="spearman")$p.value
    ci_p_1 <- cor.test(x, y, method="kendal")$p.value
    for(j in seq_along(delta_vector)){
      sgm <- delta_vector[j]
      mci <- paired.concordance.index(predictions = x_n,  observations = y, delta.pred = sgm, delta.obs = sgm)
      mci_p[j] <- mci$p.value
      
      ci_p[j] <- ci_p_1
      pearson_p[j] <- pearson_p_1
      spearman_p[j] <- spearman_p_1
      
    }
    res <- cbind(truth, ci_p, mci_p, pearson_p, spearman_p)
    colnames(res) <- c("Alternative", "CI_p", "rCI_p", "Pearson_p", "Spearman_p")
    rownames(res) <- delta_vector
    res
  }
  return(res)
}
expcis <- seq(0.5, 0.7, .01)
nsamples_loop <- c(20, 50)
list_mat <- matrix(list(), nrow = length(expcis), ncol=length(nsamples_loop), dimnames = list(expcis, nsamples_loop))
doParallel(3)
registerDoParallel(3)
nsamples = nsamples_loop[1]
eci = expcis[1]
    test <- runPowerNormalNull(exp_CI = eci, N = nsamples,sampleN=100, delta_vector = c(0, 0.5, 1), req_alpha = 0.001)
runPowerNormalNull <- function(exp_CI = 0.6, 
                           N = 50, 
                           sampleN = 10000, 
                           delta_vector = seq(0, 1, by = .05), 
                           propTrue=1, req_alpha=0.001){
  tau = 2*exp_CI - 1
  rho <- sin((pi*tau)/(2))
  
  altSigma <- c(1,rho,rho,1)
  dim(altSigma) <- c(2,2)
  
  nullSigma <- c(1,0,0,1)
  dim(nullSigma) <- c(2,2)
  
  res <- foreach(i = seq_len(sampleN), 
                 export=c("delta_vector", "nullSigma", "altSigma", "propTrue", "N", "req_alpha")) %dopar% {
    # if(i %% 10 == 0){print(i)}
    require(MASS)
    require(wCI)
    require(rmutil)
    ci_p <- numeric(length(delta_vector))
    mci_p <- numeric(length(delta_vector))
    pearson_p <- numeric(length(delta_vector))
    
    
    spearman_p <- numeric(length(delta_vector))
    
    if(runif(1) < propTrue){
      truth <- rep(1, times=length(delta_vector))
      sample_mat <- mvrnorm(n = N, mu = c(0,0), Sigma = altSigma)
      
      x <- sample_mat[,1]
      y <- sample_mat[,2]
    } else {
      truth <- rep(0, times=length(delta_vector))
      sample_mat <- mvrnorm(n = N, mu = c(0,0), Sigma = nullSigma)
      
      x <- sample_mat[,1]
      y <- sample_mat[,2]
    }
    pearson_p_1 <- pearson.perm.test(x,y,req_alpha = req_alpha)$p.value
    spearman_p_1 <- cor.test(x, y, method="spearman")$p.value
    ci_p_1 <- cor.test(x, y, method="kendal")$p.value
    for(j in seq_along(delta_vector)){
      sgm <- delta_vector[j]
      mci <- paired.concordance.index(predictions = x,  observations = y, delta.pred = sgm, delta.obs = sgm)
      mci_p[j] <- mci$p.value
      
      ci_p[j] <- ci_p_1
      pearson_p[j] <- pearson_p_1
      spearman_p[j] <- spearman_p_1
      
    }
    res <- cbind(truth, ci_p, mci_p, pearson_p, spearman_p)
    colnames(res) <- c("Alternative", "CI_p", "rCI_p", "Pearson_p", "Spearman_p")
    rownames(res) <- delta_vector
    res
  }
  return(res)
}
    test <- runPowerNormalNull(exp_CI = eci, N = nsamples,sampleN=100, delta_vector = c(0, 0.5, 1), req_alpha = 0.001)
test
    test <- runPowerNormalNull(exp_CI = eci, N = nsamples,sampleN=1000, delta_vector = c(0, 0.5, 1), req_alpha = 0.001)
test
seq_len(sampleN)
runPowerNormalNull <- function(exp_CI = 0.6, 
                           N = 50, 
                           sampleN = 10000, 
                           delta_vector = seq(0, 1, by = .05), 
                           propTrue=1, req_alpha=0.001){
  tau = 2*exp_CI - 1
  rho <- sin((pi*tau)/(2))
  
  altSigma <- c(1,rho,rho,1)
  dim(altSigma) <- c(2,2)
  
  nullSigma <- c(1,0,0,1)
  dim(nullSigma) <- c(2,2)
  
  res <- foreach(i = seq_len(sampleN), 
                 .export=c("delta_vector", "nullSigma", "altSigma", "propTrue", "N", "req_alpha")) %dopar% {
    # if(i %% 10 == 0){print(i)}
    require(MASS)
    require(wCI)
    require(rmutil)
    ci_p <- numeric(length(delta_vector))
    mci_p <- numeric(length(delta_vector))
    pearson_p <- numeric(length(delta_vector))
    
    
    spearman_p <- numeric(length(delta_vector))
    
    if(runif(1) < propTrue){
      truth <- rep(1, times=length(delta_vector))
      sample_mat <- mvrnorm(n = N, mu = c(0,0), Sigma = altSigma)
      
      x <- sample_mat[,1]
      y <- sample_mat[,2]
    } else {
      truth <- rep(0, times=length(delta_vector))
      sample_mat <- mvrnorm(n = N, mu = c(0,0), Sigma = nullSigma)
      
      x <- sample_mat[,1]
      y <- sample_mat[,2]
    }
    pearson_p_1 <- pearson.perm.test(x,y,req_alpha = req_alpha)$p.value
    spearman_p_1 <- cor.test(x, y, method="spearman")$p.value
    ci_p_1 <- cor.test(x, y, method="kendal")$p.value
    for(j in seq_along(delta_vector)){
      sgm <- delta_vector[j]
      mci <- paired.concordance.index(predictions = x,  observations = y, delta.pred = sgm, delta.obs = sgm)
      mci_p[j] <- mci$p.value
      
      ci_p[j] <- ci_p_1
      pearson_p[j] <- pearson_p_1
      spearman_p[j] <- spearman_p_1
      
    }
    res <- cbind(truth, ci_p, mci_p, pearson_p, spearman_p)
    colnames(res) <- c("Alternative", "CI_p", "rCI_p", "Pearson_p", "Spearman_p")
    rownames(res) <- delta_vector
    res
  }
  return(res)
}
    test <- runPowerNormalNull(exp_CI = eci, N = nsamples,sampleN=100, delta_vector = c(0, 0.5, 1), req_alpha = 0.001)
test
system.time(    test <- runPowerNormalNull(exp_CI = eci, N = nsamples,sampleN=100, delta_vector = c(0, 0.5, 1), req_alpha = 0.001)
)
system.time(test <- runPowerNormalNull(exp_CI = eci, N = nsamples,sampleN=1000, delta_vector = c(0, 0.5, 1), req_alpha = 0.001))
system.time(test <- runPowerNormalNull(exp_CI = eci, N = nsamples,sampleN=1000, delta_vector = c(0, 0.5, 1), req_alpha = 0.001))
test[[1]]
test
